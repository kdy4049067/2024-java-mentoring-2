
# java-calculator
계산기 기능을 구현하는 프로그램을 구현해보려고 한다.
지금까지는 그냥 기능만 구현을 했었는데 domain, controller, view를 나누어서 구현하는 것이 코드를 수정하거나 업데이트 하는데 유리하다고 생각이 들어서 그렇게 시도해보려고 한다.
더하기 빼기 나누기 곱하기 함수를 만들었는데
상수는 static final 형식으로 작성하면 좋은 점에 대해서 생각해보았다.
fianl 키워드는 변수, 메서드, 클래스에 적용할 수 있다.
변수에 적용한다면 그 변수를 사용하기 전 초기화가 필수이다.
어떤 객체에 final을 사용한다면 그 객체 외에 똑같지만 이름이 다른 객체를 생성할 수 없다. 하지만 객체 내부 멤버들이 final로 이루어지지 않았다면 내부는 변경할 수 있다.
static final로 한다면 선언시 초기화를 반드시 해줘야한다.
메서드에 final을 붙인다면 상속 받은 클래스에서 해당 메서드를 수정하지 못하게 된다.
클래스에 final을 붙이면 그 클래스를 상속 할 수 없고 재정의 할 수 없다. 유지보수차원에서 좋다.


자바 메모리 할당
jvm : java virtual machine
.java 파일을 컴파일러를 통해 .class로 변환
클래스 파일을 jvm의 클래스로더로 보냄
클래스 로더에서 jvm의 런타임 영역으로 로딩하여 메모리 저장

런타임 데이터 영역
1.static area(method Area) 중요
2.Heap area 중요
3.Stack Area 중요
4.PC Register
5.Native Method Stack

클래스 변수: static 키워드가 붙고 여러 객체에서 공통으로 사용 가능한 변수, static 메모리에 저장
인스턴스 변수: 클래스 영역에서 static이 아닌 변수, Heap 영역에 저장
지역 변수: 메서드 내부에서 선언된 변수, Stack 메모리에 저장

static 영역: static 변수, 클래스 정보, 생성자, 메소드와 같은 것들 저장
프로그램이 종료되기 전까진 메모리 상에 존재한다.

Heap 영역: 인스턴스를 생성할 때 사용되는 메모리 영역, new 키워드로 인스턴스를 생성할 때 Heap 영역에는 생성된 객체가 저장되고 Stack 영역에서는 객체 주소 값이 저장된다.
배열, 스트링등 참조형 데이터 타입 저장
호출이 종료되도 삭제 x, 가비지 컬렉터에 의해 메모리에서 해제
ex) Car a = new Car("k5")이면
a는 stack 영역에 저장되고 k5는 Heap 영역에 저장된다.

Stack 영역: 기본 자료형, 지역변수 ,매개변수가 저장되는 메모리
메서드 종료시 메모리에서 삭제
각 쓰레드마다 자신만의 stack을 가짐
쓰레드는 내부적으로 Static, Heap, Stack 영역을 가짐


테스트 진행 시 개행문자를 기준으로 index를 나누어주었는데 \n은 두 개의 문자가 아닌 한 개의 문자로 인식한다는 것을 꺠달음

list.of(array) 함수는 원본 배열의 객체가 변경되어도 변경이 안되는데
Arrays.asList(array) 함수는 원본 배열의 객체가 변경되면 변경사하잉 적용된다.

객체지향 생활체조에 대한 이해
1. 한 메서드에 한 단계의 들여쓰기만 사용 -> 여러 개의 들여쓰기를 사용한다면 한 메서드가 여러가지 일을 하고있을 가능성이 높음
2. else 문은 되도록 사용하지 않는다 --- 전략 패턴 사용(캡슐화 하여 객체 관련된 행동을 단순화 가능하게 함)
3. 모든 원시값 및 문자열 포장
4. 한 줄에 점을 하나만 찍는다. --점이 둘 이상 있다면 해당 부분을 리팩토링 해야함, 한 개의 객체만 다루어야한다. 캡슐화 관려 문제
5. 단어를 줄여쓰지 않는다. 과도한 축약은 가독성 저해
6. 모든 entity 작게 유지, 50줄 이상 클래스 또는 10개 이상 파일 패키지는 없어야한다.
7. 2개 이상의 인스턴수 변수를 가진 클래스를 쓰지 않는다.
8. 일급 컬렉션 사용
9. getter/setter/property 사용 금지

클래스를 생성한 후 다음 줄에 개행 문자를 추가해 주는 것이 자바 코딩 컨벤션 이라는 것을 알았다.

한 클래스 내부에서만 사용하는 메서드에 대해서는 접근 지정자를 private로 지정해주어야 안전하게 함수를 사용할 수 있다는 것을 알았다.

클래스에서 생성자를 통해 객체를 받아주면 객체를 더 안전하게 사용할 수 있다.