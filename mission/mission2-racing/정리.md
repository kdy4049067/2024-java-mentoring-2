만들어놓은 car객체의 기능들을 가지고 cars 도메인에 적용하기 위헤서 cars 도메인의 필드에 list형태의 car를 주입해준다.
cars 도메인에서는 car객체가 하는 기능들을 list형태로 for문을 이용해 하나하나 동작하는 식으로 구현해보았다.
service와 cars객체에 둘 다 기능을 넣으려고 하니까 main문을 작성할 때 좀 꼬인 부분이 있는 것 같다.


함수 파라미터에 final 카워드를 사용하면 함수 내부에서 해당 변수가 변경되는 것을 방지한다.

set함수는 다른 사람이 변수 값을 변경할 수 있으므로 지양

랜덤값을 뽑는 것과 같이 클래스와 상관 없는 작업은 interface로 만들어서 구현하면 더 좋을 것 같다.

메서드 역할을 하나로 나누는 것에 집중

controller 생성자를 통해 객체를 생성한다면 다른 곳에서 객체를 생성하고 컨트룰러 생성자에 넣어줘야하기 때문에 지양

우선 car객체를 list형으로 묶어서 cars 객체를 만들기로 생각을 하였다.
input을 어떻게 넣어줘야 하지 라고 생각을 했는데 for문을 돌려서 car생성자를 통해 car를 만들어주고 그것들을 list에 추가하는 방식으로 구현해보았다.

그 외의 메서드는 car객체가 움직이는 것과 똑같은 방식이고 list에 들어있던 car들을 하나하나 움직여주기 때문에 어렵지 않게 구현한 것 같다.

인터페이스로 추상 메서드를 만든 후 클래스에서 오버라이딩을 통해 구현하는 것이 좋은지 아니면 그냥 인터페이스에서 메서드 구현해주는 것이 좋은지 궁금하다.

어떤 필드를 만들 때 함수 하나에만 사용된다면 굳이 필드에 정의할 필요가 없을 것 같다.

랜덤 인터페이스를 클래스로 만들어서 사용하면 어떤 점이 다를까에 대해 생각해 보아야겠다

랜덤 인터페이스를 implements 한 채로 car클래스를 두면 car 클래스와 random 인터페이스는 강력하게 결합하게 된다는 것을 알았다.
강력하게 결합하면 한 코드가 바뀌면 다른 코드에 직접적인 영향을 끼칠 수 있으므로 좋지 않은 코드이다.
따라서 GenerateRandom 인터페이스를 구현하는 클래스를 만들고 override를 통해 구현 클래스를 완성한다.
하나의 인터페이스를 여러가지 클래스가 override를 통해 구현하면 인터페이스에서 원하는 동작을 구현체마다 다르게 설정할 수 있어서 다양한 동작을 하는 객체를 만들 수 있게된다.
구현체를 만들고 나면 car 객체에서는 생성자 주입을 통해 의존성을 주입한다. 파라미터로는 GenerateRandom을 받고 controller에서도 마찬가지로 코딩한다.
그 후 main 문에서 원하는 구현체를 생성자로 넣어주면 외부에서 의존성 주입도 되고 객체가 원하는 동작을 할 수 있게 된다,

의존성 주입을 통해서 코드의 재사용성이 높아지고, 코드의 결합도가 감소하여 하나가 달라져도 영향을 미치지 않을 수 있고, 테스트 하기도 좋아지고, 가독성도 좋아지는 장점들이 있다.

클래스 이름에 implement 같은 단어는 사용하지 않는다.
