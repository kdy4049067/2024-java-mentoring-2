리팩터링
원시값 변수를 그대로 사용하는 것보다 포장해서 사용하면 유지보수도 용이하고 클래스가 여러가지 동작을 하지 않도록 만들 수 있어서 더 객체지향적인 코드를 작성할 수 있게 된다
원시값 변수를 사용한 것을 원시값 포장해서 코드를 작성해보았다.
name과 position을 원시값 포장 했는데 클래스를 car 내부에 만들어야 하나 외부 클래스에 만들어야 하나 고민을 했다.
내부 클래스로 만들면 자동으로 static이 되어서 메모리 부분에서 안 좋다고 생각을 하여 외부에서 작성을 해보았고 외부에서 작성함으로써 재사용성이 높아진 것 같다.
원시값 포장을 사용함으로써 객체 상태를 따로 관리할 수 있게 되고 유지보수 차원에서도 좋은 코드가 된 것 같다
Position 클래스를 만들어서 사용하려 했더니 생성자를 잘못 설정해서 null 값이 발생했다. 생성자 초기화 중요
dto를 통해 객체를 생성함으로써 클래스가 깔끔해지고 데이터 전달을 안전하게 할 수 있다.
이중 for문을 해결하기 위한 작업 해야함
OCP, SRP 읽어보기
DDD, TDD 한 번 찾아서 읽어보기
원시값 포장을 이용하면 코드가 복잡해지고 성능은 좀 저하될 거 같지만 가독성 증가, 캡슐화 등이 가능하고 값과 관련된 로직 및 검증을 포함하는 것이 좋은 것 같습니다

클래스 간의 계층 위치를 위반하는 코드는 좋지 않음
public Number generateRandomNumber(){
Number number = new Number(random.nextInt(limitNumber));

        return number;
    }  --> Number와 RandomNumbers간의 위치가 애매해진다.

도메인 값을 가져온는 로직과 출력 기능이 합쳐져야 하는 상황
파라미터로 도메인을 받고 그걸로부터 필드 값을 가져오는 것도 하나의 로직으로 보는건가?
하나의 함수에서 위의 기능과 StringBuilder에 출력값 더하는 것을 처리하면 SRP를 위반하는 것인가

record의 장점
코드 간결성:
데이터 중심의 클래스를 작성할 때 필요한 반복적인 코드(getter, toString, equals 등)를 자동으로 생성합니다.
불변성 보장:
모든 필드가 기본적으로 final이므로, 데이터 무결성이 유지됩니다.
의미 전달:
record라는 키워드 자체가 "이 클래스는 데이터만 표현한다"는 의미를 전달합니다.

record의 단점
상속 불가능:
record는 암묵적으로 final로 처리되며, 상속이 불가능합니다.
이는 불변성을 유지하고 설계를 단순화하기 위한 선택입니다.
특정 로직 포함 제한:
record는 주로 데이터를 표현하는 데 사용되므로, 복잡한 로직을 포함하기에 적합하지 않습니다.

만들어놓은 car객체의 기능들을 가지고 cars 도메인에 적용하기 위헤서 cars 도메인의 필드에 list형태의 car를 주입해준다.
cars 도메인에서는 car객체가 하는 기능들을 list형태로 for문을 이용해 하나하나 동작하는 식으로 구현해보았다.
service와 cars객체에 둘 다 기능을 넣으려고 하니까 main문을 작성할 때 좀 꼬인 부분이 있는 것 같다.

함수 파라미터에 final 카워드를 사용하면 함수 내부에서 해당 변수가 변경되는 것을 방지한다.

set함수는 다른 사람이 변수 값을 변경할 수 있으므로 지양

랜덤값을 뽑는 것과 같이 클래스와 상관 없는 작업은 interface로 만들어서 구현하면 더 좋을 것 같다.

메서드 역할을 하나로 나누는 것에 집중

controller 생성자를 통해 객체를 생성한다면 다른 곳에서 객체를 생성하고 컨트룰러 생성자에 넣어줘야하기 때문에 지양

우선 car객체를 list형으로 묶어서 cars 객체를 만들기로 생각을 하였다.
input을 어떻게 넣어줘야 하지 라고 생각을 했는데 for문을 돌려서 car생성자를 통해 car를 만들어주고 그것들을 list에 추가하는 방식으로 구현해보았다.

그 외의 메서드는 car객체가 움직이는 것과 똑같은 방식이고 list에 들어있던 car들을 하나하나 움직여주기 때문에 어렵지 않게 구현한 것 같다.

인터페이스로 추상 메서드를 만든 후 클래스에서 오버라이딩을 통해 구현하는 것이 좋은지 아니면 그냥 인터페이스에서 메서드 구현해주는 것이 좋은지 궁금하다.

어떤 필드를 만들 때 함수 하나에만 사용된다면 굳이 필드에 정의할 필요가 없을 것 같다.

랜덤 인터페이스를 클래스로 만들어서 사용하면 어떤 점이 다를까에 대해 생각해 보아야겠다

랜덤 인터페이스를 implements 한 채로 car클래스를 두면 car 클래스와 random 인터페이스는 강력하게 결합하게 된다는 것을 알았다.
강력하게 결합하면 한 코드가 바뀌면 다른 코드에 직접적인 영향을 끼칠 수 있으므로 좋지 않은 코드이다.
따라서 GenerateRandom 인터페이스를 구현하는 클래스를 만들고 override를 통해 구현 클래스를 완성한다.
하나의 인터페이스를 여러가지 클래스가 override를 통해 구현하면 인터페이스에서 원하는 동작을 구현체마다 다르게 설정할 수 있어서 다양한 동작을 하는 객체를 만들 수 있게된다.
구현체를 만들고 나면 car 객체에서는 생성자 주입을 통해 의존성을 주입한다. 파라미터로는 GenerateRandom을 받고 controller에서도 마찬가지로 코딩한다.
그 후 main 문에서 원하는 구현체를 생성자로 넣어주면 외부에서 의존성 주입도 되고 객체가 원하는 동작을 할 수 있게 된다,

의존성 주입을 통해서 코드의 재사용성이 높아지고, 코드의 결합도가 감소하여 하나가 달라져도 영향을 미치지 않을 수 있고, 테스트 하기도 좋아지고, 가독성도 좋아지는 장점들이 있다.

클래스 이름에 implement 같은 단어는 사용하지 않는다.
